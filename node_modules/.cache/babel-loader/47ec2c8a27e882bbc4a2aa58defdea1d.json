{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Daniel Roncaglia\\\\Desktop\\\\shareyourgoals\\\\share\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/* fork of https://github.com/lovasoa/react-contenteditable */\nimport React from 'react';\n\nvar Editable =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Editable, _React$Component);\n\n  function Editable() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Editable);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Editable)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _this.preventEnter = function (evt) {\n      if (evt.which === 13) {\n        evt.preventDefault();\n\n        if (!_this.htmlEl) {\n          return false;\n        }\n\n        _this.htmlEl.blur();\n\n        return false;\n      }\n    };\n\n    _this.emitChange = function (evt) {\n      if (!_this.htmlEl) {\n        return false;\n      }\n\n      var html = _this.htmlEl.innerHTML;\n\n      if (_this.props.onChange && html !== _this.lastHtml) {\n        evt.target.value = html;\n\n        _this.props.onChange(evt, html);\n      }\n\n      _this.lastHtml = html;\n    };\n\n    return _this;\n  }\n\n  _createClass(Editable, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      // We need not rerender if the change of props simply reflects the user's\n      // edits. Rerendering in this case would make the cursor/caret jump.\n      return (// Rerender if there is no element yet...\n        !this.htmlEl // ...or if html really changed... (programmatically, not by user edit)\n        || nextProps.html !== this.htmlEl.innerHTML && nextProps.html !== this.props.html // ...or if editing is enabled or disabled.\n        || this.props.disabled !== nextProps.disabled\n      );\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {\n        // Perhaps React (whose VDOM gets outdated because we often prevent\n        // rerendering) did not update the DOM. So we update it manually now.\n        this.htmlEl.innerHTML = this.props.html;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          tagName = _this$props.tagName,\n          html = _this$props.html,\n          onChange = _this$props.onChange,\n          props = _objectWithoutProperties(_this$props, [\"tagName\", \"html\", \"onChange\"]);\n\n      var domNodeType = tagName || 'div';\n\n      var elementProps = _objectSpread({}, props, {\n        ref: function ref(e) {\n          return _this2.htmlEl = e;\n        },\n        onKeyDown: this.preventEnter,\n        onInput: this.emitChange,\n        onBlur: this.props.onBlur || this.emitChange,\n        contentEditable: !this.props.disabled\n      });\n\n      var children = this.props.children;\n\n      if (html) {\n        elementProps.dangerouslySetInnerHTML = {\n          __html: html\n        };\n        children = null;\n      }\n\n      return React.createElement(domNodeType, elementProps, children);\n    }\n  }]);\n\n  return Editable;\n}(React.Component);\n\nexport { Editable as default };","map":{"version":3,"sources":["C:\\Users\\Daniel Roncaglia\\Desktop\\shareyourgoals\\share\\src\\components\\ContentEditable\\Editable.js"],"names":["React","Editable","preventEnter","evt","which","preventDefault","htmlEl","blur","emitChange","html","innerHTML","props","onChange","lastHtml","target","value","nextProps","disabled","tagName","domNodeType","elementProps","ref","e","onKeyDown","onInput","onBlur","contentEditable","children","dangerouslySetInnerHTML","__html","createElement","Component"],"mappings":";;;;;;;;AAAA;AACA,OAAOA,KAAP,MAAkB,OAAlB;;IAEqBC,Q;;;;;;;;;;;;;;;;;;UAqBnBC,Y,GAAe,UAACC,GAAD,EAAS;AACtB,UAAIA,GAAG,CAACC,KAAJ,KAAc,EAAlB,EAAsB;AACpBD,QAAAA,GAAG,CAACE,cAAJ;;AACA,YAAI,CAAC,MAAKC,MAAV,EAAkB;AAChB,iBAAO,KAAP;AACD;;AACD,cAAKA,MAAL,CAAYC,IAAZ;;AACA,eAAO,KAAP;AACD;AACF,K;;UACDC,U,GAAa,UAACL,GAAD,EAAS;AACpB,UAAI,CAAC,MAAKG,MAAV,EAAkB;AAChB,eAAO,KAAP;AACD;;AACD,UAAMG,IAAI,GAAG,MAAKH,MAAL,CAAYI,SAAzB;;AACA,UAAI,MAAKC,KAAL,CAAWC,QAAX,IAAuBH,IAAI,KAAK,MAAKI,QAAzC,EAAmD;AACjDV,QAAAA,GAAG,CAACW,MAAJ,CAAWC,KAAX,GAAmBN,IAAnB;;AACA,cAAKE,KAAL,CAAWC,QAAX,CAAoBT,GAApB,EAAyBM,IAAzB;AACD;;AACD,YAAKI,QAAL,GAAgBJ,IAAhB;AACD,K;;;;;;;0CAxCqBO,S,EAAW;AAC/B;AACA;AACA,aACE;AACA,SAAC,KAAKV,MAAN,CACA;AADA,WAEIU,SAAS,CAACP,IAAV,KAAmB,KAAKH,MAAL,CAAYI,SAA/B,IACCM,SAAS,CAACP,IAAV,KAAmB,KAAKE,KAAL,CAAWF,IAHnC,CAIA;AAJA,WAKG,KAAKE,KAAL,CAAWM,QAAX,KAAwBD,SAAS,CAACC;AAPvC;AASD;;;yCACoB;AACnB,UAAI,KAAKX,MAAL,IAAe,KAAKK,KAAL,CAAWF,IAAX,KAAoB,KAAKH,MAAL,CAAYI,SAAnD,EAA8D;AAC5D;AACA;AACA,aAAKJ,MAAL,CAAYI,SAAZ,GAAwB,KAAKC,KAAL,CAAWF,IAAnC;AACD;AACF;;;6BAsBQ;AAAA;;AAAA,wBACuC,KAAKE,KAD5C;AAAA,UACCO,OADD,eACCA,OADD;AAAA,UACUT,IADV,eACUA,IADV;AAAA,UACgBG,QADhB,eACgBA,QADhB;AAAA,UAC6BD,KAD7B;;AAGP,UAAMQ,WAAW,GAAGD,OAAO,IAAI,KAA/B;;AACA,UAAME,YAAY,qBACbT,KADa;AAEhBU,QAAAA,GAAG,EAAE,aAACC,CAAD;AAAA,iBAAO,MAAI,CAAChB,MAAL,GAAcgB,CAArB;AAAA,SAFW;AAGhBC,QAAAA,SAAS,EAAE,KAAKrB,YAHA;AAIhBsB,QAAAA,OAAO,EAAE,KAAKhB,UAJE;AAKhBiB,QAAAA,MAAM,EAAE,KAAKd,KAAL,CAAWc,MAAX,IAAqB,KAAKjB,UALlB;AAMhBkB,QAAAA,eAAe,EAAE,CAAC,KAAKf,KAAL,CAAWM;AANb,QAAlB;;AASA,UAAIU,QAAQ,GAAG,KAAKhB,KAAL,CAAWgB,QAA1B;;AACA,UAAIlB,IAAJ,EAAU;AACRW,QAAAA,YAAY,CAACQ,uBAAb,GAAuC;AAAEC,UAAAA,MAAM,EAAEpB;AAAV,SAAvC;AACAkB,QAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,aAAO3B,KAAK,CAAC8B,aAAN,CAAoBX,WAApB,EAAiCC,YAAjC,EAA+CO,QAA/C,CAAP;AACD;;;;EA7DmC3B,KAAK,CAAC+B,S;;SAAvB9B,Q","sourcesContent":["/* fork of https://github.com/lovasoa/react-contenteditable */\r\nimport React from 'react'\r\n\r\nexport default class Editable extends React.Component {\r\n  shouldComponentUpdate(nextProps) {\r\n    // We need not rerender if the change of props simply reflects the user's\r\n    // edits. Rerendering in this case would make the cursor/caret jump.\r\n    return (\r\n      // Rerender if there is no element yet...\r\n      !this.htmlEl\r\n      // ...or if html really changed... (programmatically, not by user edit)\r\n      || (nextProps.html !== this.htmlEl.innerHTML\r\n        && nextProps.html !== this.props.html)\r\n      // ...or if editing is enabled or disabled.\r\n      || this.props.disabled !== nextProps.disabled\r\n    )\r\n  }\r\n  componentDidUpdate() {\r\n    if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {\r\n      // Perhaps React (whose VDOM gets outdated because we often prevent\r\n      // rerendering) did not update the DOM. So we update it manually now.\r\n      this.htmlEl.innerHTML = this.props.html\r\n    }\r\n  }\r\n  preventEnter = (evt) => {\r\n    if (evt.which === 13) {\r\n      evt.preventDefault()\r\n      if (!this.htmlEl) {\r\n        return false\r\n      }\r\n      this.htmlEl.blur()\r\n      return false\r\n    }\r\n  }\r\n  emitChange = (evt) => {\r\n    if (!this.htmlEl) {\r\n      return false\r\n    }\r\n    const html = this.htmlEl.innerHTML\r\n    if (this.props.onChange && html !== this.lastHtml) {\r\n      evt.target.value = html\r\n      this.props.onChange(evt, html)\r\n    }\r\n    this.lastHtml = html\r\n  }\r\n  render() {\r\n    const { tagName, html, onChange, ...props } = this.props\r\n\r\n    const domNodeType = tagName || 'div'\r\n    const elementProps = {\r\n      ...props,\r\n      ref: (e) => this.htmlEl = e,\r\n      onKeyDown: this.preventEnter,\r\n      onInput: this.emitChange,\r\n      onBlur: this.props.onBlur || this.emitChange,\r\n      contentEditable: !this.props.disabled,\r\n    }\r\n\r\n    let children = this.props.children\r\n    if (html) {\r\n      elementProps.dangerouslySetInnerHTML = { __html: html }\r\n      children = null\r\n    }\r\n    return React.createElement(domNodeType, elementProps, children)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}